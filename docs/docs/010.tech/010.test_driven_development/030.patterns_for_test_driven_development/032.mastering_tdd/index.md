# 第 32 章 TDD を身につける

-   この章では TDD を日々のプラクティスとして取り入れる際にぶつかる疑問や、考えておくべきことを紹介する

## 一歩の大きさはどれくらいか

-   本節の問いには 2 つのものが潜んでいる
    -   各々のテストがどのくらいカバーすべきか
    -   リファクタリングの仮定で中継地点をどのくらい作るか
-   テストの「一歩の大きさ」は大小どちらでも実現できるようにしておくと良い
    -   TDD は基本的に小さなステップを踏むが、プロジェクトによって大きさは変動する
    -   アプリケーションレベルのテストのみで駆動する場合もあり得る
-   リファクタリングを行う際には、十分小さいステップで進めるようにする
    -   手作業で行うリファクタリングは間違いが起こりやすい

## テストしなくてもよいものはあるか

-   「不安が退屈に変わるまでテストを書く」ことが一つの目安である
-   基本的に、以下の観点はテストすべきである
    -   条件分岐
    -   ループ
    -   操作
    -   ポリモーフィズム
-   ただし、自身が実装するものに限る
    -   学習用テスト以外で、外部が作成したコードをテストする必要はない

## 良いテストを見分けることができるか

-   設計に問題を抱えている場合、テストに以下のような兆候が現われる
    -   前準備に要するコードが長い
    -   互いに密に関連しあうオブジェクトが多く、前準備コードが重複している
    -   テスト実行時間が長く、テストの実行頻度が低い
    -   思わぬタイミングで失敗するような脆いテストがある

## TDD はどのようにフレームワークを導くか

-   TDD に従って開発をしていくと、発生した新たなバリエーションを正確に表現できる
    -   これまでの機能との重複部分は 1 つにまとめられ、差異はメソッドやクラスで分かれる
-   バリエーションの導入が速くなればなるほど、外から見ると TDD は事前設計と見分けがつかなくなる
    -   素早く重複を削除していけるため、まるで最終的に出来上がるコードが最初から頭の中にあったように見える

## どのくらいフィードバックが必要か

-   どのくらいのテストを書けばよいかについては、MTBF（平均故障間隔）を参考にすると良い
    -   MTBF に 10 年から 100 年くらいまでを考えるのなら、あらゆる可能性のテストを記載する必要がある
    -   逆に、MTBF が短い期間ならば、重要なパターンだけをテストすればよい
-   TDD におけるテストの考え方は実用主義に貫かれている
    -   TDD において、テストコードは自信のあるコードを実装することを目的としている

## どのようなときにテストを消すべきか

-   テストの数は多いに越したことはないが、テスト間に重複が発生した場合、以下の観点を持って削除するか判断する
    -   テストを消すことでシステムの振る舞いに対する自信が減らないか
    -   2 つのテストが読み手にとって異なるシナリオであるか

## プログラミング言語や環境は TDD に依存するか

-   TDD のサイクルが面倒なプログラミング言語や環境を使う場合、大きなステップを踏みたくなる可能性が高い
    -   しかし、大きなステップを踏むことで、結果的に TDD の効果を十分に受けることができない（テストを通すまで多くの時間がかかる）
-   TDD のサイクルを回しやすい言語や開発環境を使うことで、結果的に開発効率を上げる

## 巨大なシステムをテスト駆動できるか

-   筆者がこれまでに参加した最大規模の TDD プロジェクトは、テストコード、プロダクトコード共に 250,000 行の非常に大きなプロジェクトである
    -   結果的に、十分に TDD のサイクルを回すことができていた
    -   機能の総量と TDD の有効性は無関係である

## アプリケーションレベルのテストで開発を駆動できるか

-   小さいテストで開発を駆動する際に問題となるのは、実装した機能が結果的に顧客が望んでいるものとは全く別物だった、というリスクである
-   そのため、アプリケーションレベルのテストを書いて、顧客とコミュニケーションを取るのが有効である
-   しかし、技術的、文化的両面での課題が発生する
    -   アプリケーションレベルでのフィクスチャーが必要になる
    -   顧客への責務（要件の確認）が新たに加わる
-   また、アプリケーションレベルのテストでは、テストが通るまで非常に時間がかかり、TDD のサイクルを短いスパンで回すことができない

## 途中から TDD に乗り換えるにはどうすればよいか

-   開発途中のプロダクトコードに対して、続きから TDD に移行することを考える
    -   テストのことを考えずに書かれたコードは、テストが書きにくい可能性が高い
        -   インターフェースが設計されていないため、ロジックを一部切り出して結果を確かめることしかできない
    -   コードを書きなおすことも難しい
        -   自動テストを伴わないリファクタリングは失敗しやすい
        -   失敗したとしても、テストがないため検知できない（ある種のデッドロックに陥る）
    -   一からすべて TDD にしようとすると、新たな機能を生み出さないまま大きな時間を費やすことになる
-   以下のプロセスに従うことを推奨する
    -   まず、システム全体ではなく、変更するスコープを狭める
    -   次に、以下のような方法でテストとリファクタリングの間のデッドロックを解消する
        -   簡易的に大きな単位でテストを作成する
        -   ペアで慎重に作業をして、どうにか抜け出す
    -   上記を繰り返していくことで、少しずつ TDD のサイクルに近づけていく

## TDD は誰のためのものか

-   TDD を行うと、正しいタイミングで正しい問いに気づけるようになり、よりきれいな設計になる
-   ただし、優れたエンジニアリングがプロジェクトの成功に寄与する割合は 20%程度である
    -   その観点では、TDD はやりすぎである
-   しかし、実装をしていく中で自信を持って進めていき、設計をより洗練させたい全てのエンジニアにとって、TDD は適していると考えられる

## TDD は初期状況に左右されるか

-   テストをスムーズに回すには以下の順序に従う必要がある
    -   レッド、グリーン、リファクタリング、レッド、グリーン、リファクタリング…
-   もし異なる順序で実装した場合、小さいステップで進めることは出来ない
-   （メモ）この後の解釈が難しい・・・。初期状況とは何を指しているのか？

## TDD とパターンの関係

-   一般的に学習とは、模倣したい熟練者を見つけ、模倣することで、段々と実際に何が起こっているのかを理解する
-   反復可能な振る舞いを規則にまで還元することで、規則の適用は機械的に反復可能になる
-   TDD を活用することで、慎重に完璧に考え抜いた設計よりも素晴らしいものになる可能性もある

## なぜ TDD は機能するのか

-   素晴らしいコードを実現するカギは欠陥を減らすことにある
    -   欠陥を見つけてから修正するまでの時間が短ければ、少ないコストで実現できる
-   TDD を適用することで、多くのことを一度に心配する必要がなくなる
    -   今向かっているテストだけに集中すればよい
    -   その他のコードは、他のテストが保証している

## 名前の由来は

### テスト

-   自動化された、具体化された、明確なテストという意味
    -   ボタンを押せば走り出す
-   TDD は分析技法であり、設計技法であり、実際には開発のすべてのアクティビティを構造化する技法である

### 駆動

-   筆者は元々、TDD を「テストファーストプログラミング」と呼んでいた
    -   しかし「先に」の反対派「後から」であり、コードの実装の後からテストを書くプロセスに違和感はない
    -   「構造化プログラミング」のように、命名には反対語を使用すると違和感であるものを採用するとよい
        -   どんなエンジニアも「非構造化」なプログラミングは行いたくない
-   実際のところ、まさにテストで開発を駆動している

### 開発

-   ソフトウェア開発におけるどこかのフェーズを指すつもりがなかった
-   開発は分析、論理設計、物理設計、実装、テスト、レビュー、結合、デプロイを伴うすべてのフェーズを指す

## TDD と XP(eXtreme Programming)のプラクティスとの関係

-   TDD がどうやって他の XP プラクティスを強化するかを簡単に説明する

### ペアプログラミング

-   TDD で書くテストは、ペアで議論する際の理想的な媒体となる
    -   ペアで立ち向かう目的が明確となるため

### いきいきとした仕事

-   XP は元気なうちに働き、疲れたらやめることを推奨する
-   今書いているテストがなかなか通らない場合、一度休憩をとると良い

### 継続的インテグレーション

-   テストは頻繁なインテグレーションを可能にするリソースとしても最適である
-   TDD の 1 サイクルは 15 分から 30 分を目標とする
    -   細かくインテグレーションが行われ、より強固に進化していくことができる

### インクリメンタルな設計

-   テストのために必要なコードだけを書き、すべての重複を除去すると、現在の要件に最も適応し、かつ将来のストーリーに対する備えともなる設計が自動的に得られる

### リファクタリング

-   TDD に従ってリファクタリングを行っても、システムの振る舞いが変わっていないことを保証し続ける
-   より積極的に大きいリファクタリングに取り組めるようになる
    -   その結果、システムの寿命を延ばす

### 継続的デリバリー

-   TDD のテストがシステムの MTBF を改善するのであれば、顧客に影響なくコードを頻繁に本番環境に配備できるようになる

## Darach の挑戦

-   Darach Ennis は、TDD の適用範囲を広げる為に活動しており、**以下のようなことはない**と主張している

    -   GUI の自動テストは出来ない
    -   分散システムの自動テストは出来ない
    -   データベーススキーマのテストを先に書くことはできない
    -   サードパーティのコードや、ツールで自動生成されたコードをテストする必要はない
    -   テストファーストでプログラミング言語のコンパイラやインタプリタを BNF から実際に使えるレベルまで育てることは出来ない
