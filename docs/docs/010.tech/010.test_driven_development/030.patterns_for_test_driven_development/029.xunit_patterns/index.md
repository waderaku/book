# 第 29 章 xUnit のパターン

## アサーション

-   テストをきちんと動作させるには、コードがきちんと動いているかを真偽値で返し、自動的に判断出来るようにすると良い
    -   真の場合は成功、偽の場合は何か問題が発生している、とはっきりさせるために、判断は真偽値を使用する
    -   真偽値の調査はコンピュータに行わせ、自動化する
-   判断式は、意図を正確に反映したものにする
    -   `assertTrue(rectangle.area() != 0)`のようなアサーションでは、null 以外の値を返せばテストが通ってしまう
    -   area メソッドが 50 を返すべきであるならば、`assertTrue(rectangle.area() == 50)`のように実装すべきである
-   オブジェクトをブラックボックスとして捉えるにはコツが必要である

    -   Contract オブジェクトが Status オブジェクトを保持しており、（あくまで現在の実装では）その実体は Offered クラスか Running クラスであるとする
    -   この時、以下の様なテストを書いてしまうのは誤りである

    ```java
    Contract contract = new Contract();
    contract.begin();
    assertEquals(Running.class, contract.status.class);
    ```

    -   このテストは現在の実装に依存しており、コンシューマ目線の実装になっていない
        -   内部でどんな実装が行われているかをテストが知っている状態になっている
    -   本来なら、status の表現が真偽値に変わっても通るようなテストにするべきである（例えば、contract の開始日時が現在日時であることを確認するなど）

-   xUnit の機能は拡張しており、ホワイトボックスのテスト(private 変数に対するテスト)も実現できるようになっている
    -   しかし、ホワイトボックステストを書きたくなる時は、設計上の問題がある可能性が高い
    -   コードが正しく動いているかを判断するためには、本来公開されている情報で十分なはずである
-   JUnit を代表とする多くのテスティングフレームワークでは、アサーションメッセージを自分で書くことができる
    -   エラーの原因にたどり着くための手助けとなるので、便利な可能性が高い
    -   しかし、その分コストもかかるため、プロジェクトの難易度に対して割に合うかは判断が必要である

## フィクスチャー

-   複数のテストで使用される共通のオブジェクトについては、テストメソッド内のローカル変数をインスタンス変数に変更し、set_up メソッドで共通的にインスタンス化すると良い
-   プロダクトコードと同様、テストコードでも不要な重複は避けたい
    -   重複は無駄な工数を生む
    -   インターフェースの変更が発生した際、多くのテストコードを変更しなければならなくなる
-   ただし、重複をそのまま残しておくのも意義がある
    -   テスト準備のコードがアサーションと同じ場所で書かれている場合、テストは上から下へ読みやすくなる
    -   前準備のコードを別メソッドに抽出すると、テストコードを追うために様々な箇所を追う必要がある
-   そのため、テストフィクスチャーを作り上げるコードは、テストの読み手が解読に苦労するようなら、テストメソッドの中に書くのも手である
-   どちらの方が適するかは、プロジェクトとそのチームによるため、都度考慮する必要がある
    -   筆者は多くの場合、共通コードを抽出する

## 外部フィクスチャー

-   フィクスチャーとして作成した外部リソースを解放するには、tear_down メソッドをオーバーライドし、その中でリソースを開放するとよい
-   テストメソッドは、実行前の状態を完全に復元するように心がけなくてはならない
    -   各テストの独立性を担保する必要がある
-   例えば、テストコード上でファイルの開いたならば、テスト完了時に閉じる必要がある
    -   全てのテストコードでファイルを閉じる実装をすると無駄な重複が発生する
    -   tear_down に抽出すると、各テストの独立性を 1 つのメソッドで担保できる

## テストメソッド

-   オブジェクト指向プログラミング言語は、次の 3 つの階層構造で整理できるようになっている
    -   モジュール
    -   クラス
    -   メソッド
-   テストもコードとして書くからには、この構造に当てはまる
    -   もしフィクスチャーをクラスで表現したなら、テストはメソッドとして書かれることになる
    -   同じフィクスチャーを使用する複数のテストは、同じテストクラスの中に書かれた複数のテストメソッドとして表現される
-   メソッド名は、他の開発者にとってこのテストが書かれた理由を伝えるものにする
    -   例えば、「testAssertPosInfinityNotEqualsNegInfinity」というテストメソッドがあれば、当時無限大の正負を区別していなかったことが分かる
-   テストメソッドは、そのテストで確認したい観点についての最小のテストを記載することを心がける
    -   究極的には、1 つのテストメソッドは 3 行程度になるはずである

## 例外のテスト

-   例外発生を期待するテストは、期待される例外をキャッチして握りつぶすように書いて、その例外が発生しなかったときだけテストが失敗するようにすると良い
-   値の検索を行うコードを例に考える

    -   値の検索のテスト自体は非常に単純である

    ```java
    @Test
    public void testRate() {
        exchange.addRate("USD", "GBP", 2);
        int rate = exchange.findRate("UDS", "GBP");
        assertEquals(2, rate);
    }
    ```

    -   例外のテストは以下のように実装する

    ```java
    @Test
    public void testMissingRate() {
        try {
            exchange.findRate("UDS", "GBP");
            fail();
        }
        catch (IllegalArgumentException expected){
        }
    }
    ```

    -   findRate メソッドで想定通り例外が発生しなかった場合、fail メソッドを呼び出して、テストを失敗としている

-   例外のテストを実装する場合、想定する例外だけをキャッチするように気を付ける事

## まとめてテスト

-   全てのテストをまとめて走らせるには、全てのテストスイートをまとめたスイートを作成すると良い
-   最初はモジュールごとにまとめたテストスイートを作成し、最終的にはそのテストスイートたちをまとめたアプリケーション全体のテストスイートを作成する
