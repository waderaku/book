# 第 30 章 デザインパターン

-   本章では、様々なデザインパターンを紹介する

-   本章の中で紹介するデザインパターンが TDD の中でどのように使用されるかを、以下の表にまとめる

    | パターン             | テスト | リファクタリング |
    | :------------------- | :----- | :--------------- |
    | Command              | 〇     |                  |
    | Value Object         | 〇     |                  |
    | Null Object          |        | 〇               |
    | Template Method      |        | 〇               |
    | Pluggable Object     |        | 〇               |
    | Pluggable Selector   |        | 〇               |
    | Factory Method       | 〇     | 〇               |
    | Imposter             | 〇     | 〇               |
    | Composite            | 〇     | 〇               |
    | Collecting Parameter | 〇     | 〇               |

## Command パターン

-   処理の呼び出しがシンプルなメソッド呼び出しよりも、複雑になってきたときは、処理のためのオブジェクトを作成し、それを起動するようにすると良い
-   プログラミング言語は、メソッド送信(呼び出し)を簡単に行えるようになっている
    -   更に、メッセージ(メソッド名)の変更は IDE のサポートで簡単に実現できる
-   一方で、一つのメッセージを送るだけでは不十分な事がある
    -   複雑な処理を実現する仕組みをメッセージで行うより、明確かつ編集可能な方法をとる
    -   処理（コマンド）をクラスとして作成し、全てのコマンドが一貫したインターフェースに沿うようにする
        -   run メソッド、execute メソッド等を実行すると処理が行われるようにする

## Value Object パターン

-   単純にオブジェクトを作成すると、度々別名参照問題が発生する
    -   2 つのオブジェクトが第 3 のオブジェクトを共有している時、どちらかが共有オブジェクトに変更を加えたらもう 1 つのオブジェクトにも影響してしまう
-   その際、Value Object パターンは有効である
    -   Value Object は、そのオブジェクトをイミュータブルにする
    -   そのオブジェクトに変更を加えるときには、必ず変更の加わった新しいオブジェクトが返却され、元のオブジェクトには影響がない
-   Value Object を作る際には、等価性比較を実装する必要がある
    -   2 つの 5 ドルオブジェクトを作った時、参照場所が違くても 5 ドルであることは変わらない
    -   「値」として扱うオブジェクトであるならば、そのオブジェクトの内部にある「値」に注目をするべきである

## Null Object パターン

-   例外的な状態の可能性があるオブジェクトを使用する場合は、その特殊な状況を表現するオブジェクトを作り、通常のオブジェクトと同じプロトコルを実装すると良い

    ```java
    public boolean setReadOnly() {
        SecurityManager guard = System.getSecurityManager();
        if (guard != null) {
            guard.canWrite(path);
        }
        return fileSystem.setReadOnly(this);
    }
    ```

-   java.io.File の実装の中には上記のような null チェックを行っている箇所が 18 箇所もある

    -   必ず null チェックを行うより、null の場合にも同じように振舞わせる特別なオブジェクトを作ると、1 つの実装で問題なくなる

    ```java
    class LaxSecurity {
        public void canWrite(String path) {}
    }

    public static SecurityManager getSecurityManager() {
        return security == null ? new LaxSecurity() : security;
    }
    ```

-   上記のようにすれば、null の時は何もしないオブジェクトを返すことができる為、全ての null チェックを外すことができる

## Template Method パターン

-   処理の順序だけを規定するテンプレートを作成するには、他のメソッドを呼び出すだけのメソッドを書くと良い
-   典型的な例は、xUnit の構造である

    ```java
    public void runBare throws Throwable {
        setUp();
        try {
            runTest();
        }
        finally {
            tearDown();
        }
    }
    ```

    -   サブクラスを必要な時に、setUp、runTest、tearDown 等を実装すればよいようになっている

-   Template Method は、最初からそう設計するよりも、後で実装から導き出す方がよいことが多い
    -   Template Method の抽出は、重複のリファクタリングの結果である

## Pluggable Object パターン

-   様々な状態にシンプルに対応するためには、明示的な条件分岐を使う方法がある
    -   しかし、条件分岐を実装しようとすると、様々な箇所に同じ意味の条件分岐が必要なことに気づく
-   TDD 第 2 の掟は重複の排除である、条件分岐が増殖することは避けなければならない
    -   それぞれの条件分岐が行う処理に対応するようにクラスとそれぞれのクラスにメソッド群を用意する
    -   2 つのクラスのインターフェースを操作するように実装すれば、条件分岐は各クラスをインスタンス化する一か所に集約することができる

## Pluggable Selector パターン

-   Pluggable Object の目的を複数のメソッドで実現することも考えられる
-   サブクラスが 10 子もあるのに、それぞれのクラスは 1 つのメソッドしか実装していないような場合がある
    -   各クラスの振る舞いのバリエーションが少ない場合、サブクラス化は大げさになる可能性が高い
-   Pluggable Selector パターンはリフレクションで動的にメソッドの起動を行うパターンである
-   PluggableSelector パターンは処理の実行が動的に決定するため、どのメソッドが起動されるのかコードから追いにくくなるため、頻繁に使用することは避けたほうが良い

## Factory Method パターン

-   オブジェクト作成に柔軟性を持たせたい場合、コンストラクタとそのオーバーロードで実装するより、メソッドを使ってオブジェクトを作成すると良い
-   コンストラクタの場合、例えば Python ではオーバーロードができないなど、様々な問題が内蔵している
-   用途に応じたインスタンス作成のメソッドを用意すれば、表現力(メソッド名)と柔軟性が非常に高く実装できる
    -   第 Ⅰ 部では Money オブジェクトの Factory Method を作成したが、Dollar と Franc の管理方法の変更がコンシューマに影響しなくなっていた
-   Factory Method は柔軟性が高くなる一方で、その存在を知らなければならない
    -   柔軟性が不要ならば、コンストラクタを使用する方がよい

## Imporster パターン

-   現在ある処理にバリエーションを持たせたい場合、シンプルなやり方は条件分岐の追加である
    -   しかし、それを行うと同じ条件分岐が増殖してしまう
    -   そのため、例えばポリモーフィズムを利用して条件分岐を避ける
        -   Pluggable Object パターンである
-   既存の構造があり、既にオブジェクトもあるような状況を考える
    -   その場合、現在のオブジェクトと同等のインターフェースを用意し、そこにもう一つのバリエーションの実装をする
-   Null Object や Composite も Imposter の一例である

## Composite パターン

-   オブジェクトたちの振る舞いを組み合わせた振る舞いを持つオブジェクトを実装するには、構成要素を集めた Imposter を作ると良い
-   有名な例は、口座（Account）と取引（Transaction）がある
    -   Transaction は口座に入る額の増分を保持するオブジェクトであり、Account は Transaction の合算することで、口座残高を算出できる
    -   ここで、複数の口座を持っている顧客が、全ての口座の合算の残高を計算したいとする
        -   新しく口座の残高の合算を計算するオブジェクトを作成しても良いが、それでは重複が起こる
        -   Account が複数あるとき、Account と Transaction は相似の関係にあることが分かる
        -   そのため、2 つに共通するインターフェースを用意することができる
        -   そうすれば、同じ Account オブジェクトで両方の業務を実現出来る
            -   Transaction の配列を持つ一つの口座
            -   Account の配列を持つ顧客の総合口座
-   Composite パターンは実装上のテクニックであり、現実に対応しているとは限らない
    -   上記の例では、取引に残高はないが、同じインターフェースにした結果、Transaction にも残高を用意する必要が出ている(単に自身の値を返す)
    -   基本的に自分自身が入るオブジェクトというのは現実世界にはない概念だが、コードをとてもシンプルになる

## Collecting Parameter パターン

-   沢山のオブジェクトたちの処理結果を集めるためには、処理のパラメータを結果の格納用のオブジェクトを渡すと良い
-   シンプルな例として、java.io.Externalizable がある
    ```java
    public interface Externalizable extends java.io.Serializable {
        void writeExternal(ObjectOutput out) throws IOException;
    }
    ```
    -   writeExternal メソッドはオブジェクト自身と、オブジェクトが参照しているオブジェクト全てシリアライズして出力する
    -   writeExternal メソッドには ObjectOutput オブジェクトが Collecting Parameter として渡されている

## Singleton パターン

-   グローバル変数のないプログラミング言語でグローバル変数を作るには、Singleton パターンがよいが、TDD においては推奨しない
