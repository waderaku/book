# 第 31 章 リファクタリング

-   一般的なリファクタリングは、プログラムの意味を変えることは許されない
-   しかし、TDD においては、事情が異なる
    -   テストが通りさえすれば、どのような変更も許される
    -   そもそもべた書きの値を変数に書き換えていく作業は、一般にリファクタリングとは呼べない
-   そのため、機能を担保し続けるには、十分なテストを用意し、網羅性に守られたリファクタリングを行わなければならない

## 差異をなくす

-   よく似ているコードから重複を排除する場合、それぞれのコードを完全に一致させて、共通関数とする
-   対象が単純でなければ、コードを完全に一致させるステップを省略するのは問題である
    -   その共通関数への変更の設計に問題がある可能性が高い
-   時には、ゴールから考えて差異を減らしていくアプローチが必要となることがある
    -   例えば、複数のサブクラスを削除して親クラスに昇華していく事を例に考える
        -   最も小さい最終ステップは、空になったサブクラスの削除となる
        -   サブクラスのメソッドを親クラスのメソッドと完全に一致させて消していく
        -   サブクラスから 1 つずつメソッドを減らしていって、空になるところまで来たら、サブクラスの参照を親クラスの参照に置き換えていく

## 変更の分離

-   複数の部分から構成されるメソッドあるいはオブジェクトを変更する際には、まず変更すべき部分を分離独立させると良い
    -   変更箇所を分離独立させることで、対象となる部分だけに集中して取り組むことができる
-   変更を分離独立させるリファクタリングには、以下のようなものがある
    -   メソッドの抽出
    -   オブジェクトの抽出
    -   メソッドオブジェクト

## データ構造の変更

-   データの持ち方を変える際には、一度にデータ構造を変更するのではなく、データを一時的に複製すると良い

### 方法

-   データ構造の変更方法には 2 種類ある
    -   1 つ目は、内部構造を書き換えた後、外部インターフェースを変更するやり方である
        1. 新構造のためのインスタンス変数を定義する
        1. 旧構造でデータが設定されている部分をその変数に置き換える
        1. 旧構造のデータを使っている部分をその変数に置き換える
        1. 旧構造のコードを消す
        1. 外部インターフェースに新構造を反映する
    -   2 つ目は、ＡＰＩ側から変更を行う場合である
        1. 新構造のパラメータを追加する
        1. 新構造のパラメータを内部で旧構造に変換する
        1. 旧構造のパラメータを削除する
        1. 旧構造を使っている部分を新構造に置き換えていく
        1. 旧構造のコードを削除する

### 理由

-   1 つ目の方法を使用する事例を扱う
-   「一から多へ」の変更を行う際に、常にデータをどうするかに悩まされる
-   1 つのテストだけを扱える TestSuite を、多数のテストを扱えるように変更する場面を考える

    ```python
    def test_suite(self):
        suite = TestSuite()
        suite.add(WasRun("test_method"))
        suite.run(self.result)
        assert "1 run, 0 failed" == self.result.summary()

    class TestSuite:
        def add(self, test):
            self.test = test
        def run(self, result):
            self.test.run(result)
    ```

    -   ここからデータの複製を行う。まずはインスタンス変数を宣言する

    ```python
    class TestSuite:
        def __init__(self):
            self.tests = []
        def add(self, test):
            self.test = test
        def run(self, result):
            self.test.run()
    ```

    -   続いて、この配列を使用するように各メソッドに追記する

    ```python
    class TestSuite:
        def __init__(self):
            self.tests = []
        def add(self, test):
            self.test = test
            self.tests.append(test)
        def run(self, result):
            for test in self.tests:
                test.run(result)
    ```

    -   これで元の変数は不要になったため、削除することができる

    ```python
    class TestSuite:
        def __init__(self):
            self.tests = []
        def add(self, test):
            self.tests.append(test)
        def run(self, result):
            for test in self.tests:
                test.run(result)
    ```

-   この様にステップを踏んでいけば、テストを動かして現在のプログラムを壊さずに拡張ができる

## メソッドの抽出

-   込み入った長いメソッドを読みやすくするためには、メソッドの一部分を別のメソッドに分離し、そのメソッドを呼び出すようにするのが良い

### 方法

-   メソッドの抽出は厳密には複雑でアトミックなリファクタリングである
-   本節では代表的な手順を挙げる

    1. メソッドの中から新しいメソッドとして切り出す意味のある部分を探す
    1. 抽出する範囲の外で一時変数への代入が行われていないことを確認する
    1. 旧メソッドから該当範囲のコードをコピーし、コンパイルする
    1. 旧メソッドの一時変数やパラメータの中で新メソッドから使うものを、新メソッドのパラメータに追加する
    1. 旧メソッドの中から新メソッドを呼び出す

### 理由

-   メソッドの抽出を行うのは、込み入ったコードを理解したいときである
-   2 つのメソッドの一部が同じ内容で、その他の部分が異なる場合にも、メソッドの抽出を行ってその重複を除去するとよい
-   メソッドを小さいメソッドに分解する行為は、時にやりすぎを招きかねない
    -   設計に行き詰った時には、抽出したメソッドを「メソッドのインライン化」で元のメソッドに戻すことも考えるべきである

## メソッドのインライン化

-   様々な箇所に散らばった制御フローをシンプルにするには、メソッド呼び出しをその内部の処理に置き換えると良い

### 方法

1. 対象のメソッドをコピーする
1. メソッド呼び出し部分にそのメソッド本文をペーストする
1. 仮引数を実引数に置き換える

### 理由

-   メソッドのインライン化を使えば、制御フローの様々な変更を試すことができる
-   様々な変更を行っていくと、抽象的な概念の集まりとなり、メッセージの受送信を追わなければならなくなる
    -   その場合は、メソッドのインライン化を用いると良い

## インターフェースの抽出

-   ある処理の実装をもう 1 種類作るときには、インターフェースを作り、共通の処理をくくり出すと良い

### 方法

1. インターフェースを宣言する。既存クラスの名前を使用したくなった場合、先にクラスの改名を行う
1. そのインターフェースを既存クラスが実装するようにする
1. 必要なメソッドをインターフェースに加え、クラスの方では必要に応じてメソッドの可視性を上げる
1. コードの中で宣言される型を可能な限りクラスからインターフェースに書き換える

### 理由

-   インターフェースの抽出が必要になるとき、多くの場合で既に実装クラスは存在している
-   Crash Test Dummy パターンや Mock Object パターンを導入するために、インターフェースを抽出することもある
-   インターフェースの命名には、その対象を深く理解している必要がある
    -   File のインターフェースを IFile 等と名付けるのはバッドプラクティスである

## メソッドの移動

-   メソッドをふさわしい場所に移動する際には、あるべきところにメソッドを加え、それを呼び出すようにすると良い

### 方法

1. メソッドをコピーする
1. 移動先クラスにペーストし、名前を整え、コンパイルする
1. 移動元のオブジェクトがメソッド内で参照されている場合、移動元オブジェクトをメソッドのパラメータに加える。移動元オブジェクトの変数がメソッド内で参照されている場合も、それをパラメータに追加する
1. 移動元クラスのメソッドの中身を新しいメソッドの呼び出しに置き換える

### 理由

-   例えば、あるメソッドが一つのオブジェクトに対して何度もメッセージを送っている（メソッドを呼び出している）場合、一連の処理を 1 つにまとめてオブジェクト内のメソッドにすると良い
-   「メソッドの移動」リファクタリングの長所を 3 つ挙げる
    -   対象コードの意味を深くとらえなくとも、判断は簡単である。1 つのオブジェクトに対して 2 つ以上の呼び出しがあった場合は、「メソッドの移動」を考える
    -   素早く安全に行う手順が存在する
    -   目を見張るような効果を得られる可能性が高い

## メソッドオブジェクト

-   複数のパラメータやローカル変数を必要とする複雑なメソッドを表現する際には、メソッドをオブジェクトとして括りだすと良い

### 方法

1. オブジェクトを作り、メソッドと同じパラメータを保持させる
1. ローカル変数はそのオブジェクトのインスタンス変数として表現する
1. 単一のメソッド run を定義し、その中身は元のメソッドと同一にする
1. 元のメソッドの中でオブジェクトをインスタンス化し、run メソッドを呼び出す

### 理由

-   メソッドオブジェクトは、特にシステムに新しいロジックを導入する準備段階で有用である
-   メソッドオブジェクトは、メソッドの抽出に向かないコードをシンプルにすることにも役立つ
    -   その部分に対してメソッドの抽出を行おうとすると、数多くの一時変数やパラメータを渡さなければならなくなる

## パラメータの追加

### 方法

1. メソッドがインターフェースに定義されている場合は、インターフェースの方に先にパラメータを追加する
1. パラメータを追加する
1. コンパイルエラーを活用して、呼び出し側コードの修正点を調べる

### 理由

-   多くの場合、パラメータの追加は機能拡張の 1 ステップである
    -   初期段階では不要だったが、新たな処理を行うためにパラメータが追加される
-   パラメータの追加は、データ構造の変更の 1 ステップとして登場することもある
    -   まずは新しいパラメータを追加する
    -   その後古いパラメータを使っているところを消していき、最後に古いパラメータを消す

## メソッドからコンストラクタへのパラメータの移動

### 方法

1. コンストラクタへパラメータを追加する
1. そのパラメータと同名のインスタンス変数を定義する
1. コンストラクタ内でインスタンス変数への代入を行う
1. パラメータ parameter の参照を 1 つずつ this.parameter へ書き換えていく
1. パラメータへの参照がなくなったら、メソッドからパラメータを削除し、呼び出し側からも削除する
1. もうつける必要がなくなった「this.」を消していく
1. インスタンス変数をふさわしい名前に変更する

### 理由

-   あるオブジェクトの複数のメソッドに対してパラメータを渡している場合は、予めパラメータを一度だけ渡しておくことで重複を排除することができる
-   1 つのメソッドからしか使われていないインスタンス変数を見つけた場合には、このリファクタリングの逆を行えばよい
