# 第 28 章 グリーンバーのパターン

-   テストが失敗した際には、通るように修正が必要である
-   本章では、テストを通すパターンを紹介する

## 仮実装を経て本実装へ

-   最初にテストを実装したら、その次に行うことはべた書きの値を返すようにしてテストを通す

    -   そこから変更を加えていき、本物の式や変数に置き換えていく

-   第 21 章（xUnit のテスト結果を出力する機能）にて、仮実装のシンプルな例が出てきていた

    -   最初の段階では、べた書きの値を返していた

    ```python
    return "1 run, 0 failed"
    ```

    -   次に、テスト実行回数を変数に置き換えた

    ```python
    return f"{self.run_count} run, 0 failed"
    ```

    -   最後に、テスト失敗回数も変数に置き換え、本物の実装になった

    ```python
    return f"{self.run_count} run, {self.failure_count} failed"
    ```

    -   仮実装には、以下 2 つの有効性がある

        -   心理的効果

            -   実装中、テストは成功している状態を維持できる
            -   その結果、自身が現在どこまで実装を完了しているかが明確になる

        -   スコープ制御
            -   一般的に、目の前の作業に集中できれば、より良い仕事ができる
            -   一つのテストケースを書くとき、そのテストのことだけにフォーカスを当てればよい

    -   仮実装は、「不要なコード書くべからず」という掟に反しない
        -   テストコードとプロダクトコードの間に発生した重複は、リファクタリング時に取り除くからである

## 三角測量

-   テストをする際には、2 つ以上の例があるときだけ、一般化を行うようにする
-   2 つの整数を受け取って足し算を行う関数を例に考える

    ```java
    @Test
    public void testSum() {
        assertEquals(4, plus(3, 1));
    }
    private int plus(int augend, int addend) {
        return 4;
    }
    ```

    -   正しい設計へと三角測量で導くには、以下のようにテストケースを追加し、それに対応するように実装を一般化する

    ```java
    @Test
    public void testSum() {
        assertEquals(4, plus(3, 1));
        assertEquals(7, plus(3, 4));
    }
    private int plus(int augend, int addend) {
        return augend + addend;
    }
    ```

-   三角測量は、ルールが非常に明確である
    -   仮実装のルールは、テストコードとプロダクトコードの重複を意図的に発生させて開発を駆動するセンスが必要になる
    -   そこには曖昧さがあり、解釈が必要になる
-   一方で、三角測量は無限ループに入る危険性がある
    -   一般化が実現できたからと、不要になった片方のテストコードを削除すると、またべた書きに戻すことができる隙が生まれる
-   三角測量は、正しい一般化の方向が分からなかったときに使用する
    -   基本的には、仮実装あるいは明白な実装を使用することを推奨する

## 明白な実装

-   シンプルな操作を実装する場合は、仮実装をスキップしてそのまま実装してもよい
-   仮実装や三角測量は細かく刻んだ小さなステップである
    -   上記の plus メソッドのような実装が明らかな場合、流石に冗長になってしまう
-   「きれいなコード」と「動くコード」を一度に満たすのは、非常に難しい
    -   少しでも難しいと感じたら明白な実装を取りやめ、まず「動く」、その後「きれいなコード」にじっくり取り掛かるのを推奨する
-   明白な実装を行っている時は、予想に反してテストが失敗してしまう頻度に注意する
    -   あまりにも多い場合、TDD のサイクルを実現できていないことになる

## 一から多へ

-   オブジェクトのコレクションを行う操作を実装するときには、まず単数の時の操作を実装し、そこからコレクションでも動くように実装することを推奨する
-   整数の配列を合算する関数を例に考える

    -   まずは一要素から始める

    ```java
    @Test
    public void testSum() {
        assertEquals(5, sum(5));
    }
    private int sum(int value) {
        return value;
    }
    ```

    -   次に、配列を入れられるように変更する

    ```java
    @Test
    public void testSum() {
        assertEquals(5, sum(5, new int[] {5}));
    }
    private int sum(int value, int[] values) {
        int sum = 0;
        for (int i = 0; i<values.length; i++){
            sum += values[i];
        }
        return sum
    }
    ```

    -   これで元々の引数 value を使用しなくなったため、消すことができる
    -   その後、テストケースを当初考えていた配列の合算に変更する

    ```java
    @Test
    public void testSum() {
        assertEquals(12, sum(new int[] {5, 7}));
    }
    private int sum(int[] values) {
        int sum = 0;
        for (int i = 0; i<values.length; i++){
            sum += values[i];
        }
        return sum
    }
    ```
